//
//  TabletoPDFTableViewController.swift
//  FileManager
//
//  Created by Vineeth Vijayan on 04/01/16.
//  Copyright Â© 2016 Vineeth Vijayan. All rights reserved.
//

import UIKit
import SwiftFilePath

class TabletoPDFTableViewController: UITableViewController {
    
    let mainDir = "fileMangerDir"
    static var outPutPDF = ""
    @IBAction func btnConverttoPDFTapped(sender: AnyObject) {
        
        let dir = Path.documentsDir[mainDir]
        dir.mkdir()
        
        let currentText = CFAttributedStringCreate(nil,"hello world, pdf generated by swift code, this is a long text to test if the pdf is generated equally in iphone 5c and iPad I hope this much text is enough to get to multiline. " as CFStringRef,nil)
    
        let framesetter = CTFramesetterCreateWithAttributedString(currentText)
        
        let pdfFileName = Path.documentsDir[mainDir]["temp.pdf"].toString()
        
        TabletoPDFTableViewController.outPutPDF = pdfFileName
        // Create the PDF context using the default page size of 612 x 792.
        UIGraphicsBeginPDFContextToFile(pdfFileName,CGRectZero,nil)
        var currentRange = CFRangeMake(0,0)
        var currentPage = 0
        var done = false
        repeat { // Mark the beginning of a new page.
            UIGraphicsBeginPDFPageWithInfo(CGRectMake(0,0,612,792),nil)
            
            // Draw a page number at the bottom of each page.
            currentPage++
            self.drawPageNumber(currentPage)
            
            // Render the current page and update the current range to
            // point to the beginning of the next page.
            currentRange = self.renderPageWithTextRange(currentRange, andFramesetter:framesetter)
            
            // If we're at the end of the text,exit the loop.
            if (currentRange.location == CFAttributedStringGetLength(currentText)) {
                done = true
            }//((CFAttributedStringRef)currentText)) done = true
            
        } while (!done)
        // Close the PDF context and write the contents out.
        UIGraphicsEndPDFContext()
        
        // Release the framewetter.
        //                CFRelease(framesetter)
    }
    
    func renderPageWithTextRange(var currentRange: CFRange, andFramesetter framesetter: CTFramesetterRef)->CFRange{
        let currentContext = UIGraphicsGetCurrentContext()
        // Put the text matrix into a known state. This ensures
        // that no old scaling factors are left in place.
        CGContextSetTextMatrix(currentContext,CGAffineTransformIdentity)
        // Create a path object to enclose the text. Use 72 point
        // margins all around the text.
        let frameRect = CGRectMake(72,72,468,648)
        let framePath = CGPathCreateMutable()
        CGPathAddRect(framePath,nil,frameRect)
        // Get the frame that will do the rendering.
        // The currentRange variable specifies only the starting point. The framesetter
        // lays out as much text as will fit into the frame.
        let frameRef = CTFramesetterCreateFrame(framesetter,currentRange,framePath,nil)
        //            CGPathRelease(framePath)
        // Core Text draws from the bottom-left corner up,so flip
        // the current transform prior to drawing.
        CGContextTranslateCTM(currentContext,0,792)
        CGContextScaleCTM(currentContext,1.0,-1.0)
        // Draw the frame.
        CTFrameDraw(frameRef,currentContext!)
        
        
        
        let testView = self.view // [[UIView alloc] initWithFrame:CGRectMake(0.0f, 0.0f, 1024.0f, 768.0f)];
        
        //        let pdfImage = NSMutableData()
        testView.layer.renderInContext(currentContext!)
            
        // Update the current range based on what was drawn.
        currentRange = CTFrameGetVisibleStringRange(frameRef)
        currentRange.location += currentRange.length
        currentRange.length = 0
        
        
        //            CFRelease(frameRef)
        return currentRange
        //        }
    }
    
    func drawPageNumber(pageNum: Int){
        
        let pageString: NSString = ("Page " + pageNum.description)
        let theFont = UIFont.systemFontOfSize(12)
        let maxSize = CGSizeMake(612,72)
        
        let attributes = [NSFontAttributeName: UIFont(name: "HelveticaNeue", size: 14)!]

        let pageStringSize = pageString.sizeWithAttributes(attributes)
        let stringRect = CGRectMake(((612.0 - pageStringSize.width) / 2.0),720.0 + ((72.0 - pageStringSize.height) / 2.0),pageStringSize.width,pageStringSize.height)
        
//        let textFontAttributes = [
//            NSFontAttributeName: actualFont,
//            NSForegroundColorAttributeName: textColor,
//            NSParagraphStyleAttributeName: textStyle
//        ]
        pageString.drawInRect(stringRect, withAttributes: attributes) //stringRect,withFont:theFont)
        
    }
   
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // Uncomment the following line to preserve selection between presentations
        // self.clearsSelectionOnViewWillAppear = false
        
        // Uncomment the following line to display an Edit button in the navigation bar for this view controller.
        // self.navigationItem.rightBarButtonItem = self.editButtonItem()
    }
    
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    // MARK: - Table view data source
    
    override func numberOfSectionsInTableView(tableView: UITableView) -> Int {
        // #warning Incomplete implementation, return the number of sections
        return 1
    }
    
    override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        // #warning Incomplete implementation, return the number of rows
        return 25
    }
    
    
    override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCellWithIdentifier("basicCell", forIndexPath: indexPath)
        
        // Configure the cell...
        
        cell.textLabel?.text = "Row : " + indexPath.row.description
        
        return cell
    }
    
    
    /*
    // Override to support conditional editing of the table view.
    override func tableView(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath) -> Bool {
    // Return false if you do not want the specified item to be editable.
    return true
    }
    */
    
    /*
    // Override to support editing the table view.
    override func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {
    if editingStyle == .Delete {
    // Delete the row from the data source
    tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Fade)
    } else if editingStyle == .Insert {
    // Create a new instance of the appropriate class, insert it into the array, and add a new row to the table view
    }
    }
    */
    
    /*
    // Override to support rearranging the table view.
    override func tableView(tableView: UITableView, moveRowAtIndexPath fromIndexPath: NSIndexPath, toIndexPath: NSIndexPath) {
    
    }
    */
    
    /*
    // Override to support conditional rearranging of the table view.
    override func tableView(tableView: UITableView, canMoveRowAtIndexPath indexPath: NSIndexPath) -> Bool {
    // Return false if you do not want the item to be re-orderable.
    return true
    }
    */
    
    /*
    // MARK: - Navigation
    
    // In a storyboard-based application, you will often want to do a little preparation before navigation
    override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
    // Get the new view controller using segue.destinationViewController.
    // Pass the selected object to the new view controller.
    }
    */
    
}

extension UITableView {
    
    func toPDF(fileName: String) -> String {
        // Don't include scroll indicators in file
        self.showsVerticalScrollIndicator = false
        
        // Creates a mutable data object for updating with binary data, like a byte array
        let pdfData = NSMutableData()
        
        // Change the frame size to include all data
        let originalFrame = self.frame
        self.frame = CGRectMake(self.frame.origin.x, self.frame.origin.y, self.contentSize.width, self.contentSize.height)
        
        // Points the pdf converter to the mutable data object and to the UIView to be converted
        UIGraphicsBeginPDFContextToData(pdfData, self.bounds, nil)
        UIGraphicsBeginPDFPage()
        let pdfContext = UIGraphicsGetCurrentContext();
        
        // Draws rect to the view and thus this is captured by UIGraphicsBeginPDFContextToData
        self.layer.renderInContext(pdfContext!)
        
        // Remove PDF rendering context
        UIGraphicsEndPDFContext()
        
        // Retrieves the document directories from the iOS device
        let documentDirectories: NSArray = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)
        
        let documentDirectory = documentDirectories.objectAtIndex(0)
        let documentDirectoryFilename = documentDirectory.stringByAppendingPathComponent(fileName);
        
        // Instructs the mutable data object to write its context to a file on disk
        pdfData.writeToFile(documentDirectoryFilename, atomically: true)
        
        // Back to normal size
        self.frame = originalFrame
        
        // Put back the scroll indicator
        self.showsVerticalScrollIndicator = true
        
        return documentDirectoryFilename
    }
    
}
